Object subclass: #Subtitle	instanceVariableNames: 'number lines start end newStart newEnd'	classVariableNames: ''	package: 'Subtitles'!!Subtitle methodsFor: 'accessing'!end	^ end! !!Subtitle methodsFor: 'accessing'!lines: aCollection	lines := aCollection asOrderedCollection! !!Subtitle methodsFor: 'accessing'!initialize	number := 1.	lines := OrderedCollection new.	start := Duration new.	end := Duration new.! !!Subtitle methodsFor: 'accessing'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: '(';		nextPutAll: self number asString;		nextPutAll: ', ';		nextPutAll: self start asString;		nextPutAll: ')'! !!Subtitle methodsFor: 'accessing'!newStart	^ newStart! !!Subtitle methodsFor: 'accessing'!gtItemsFor: aView	<gtView>	^ aView forward		title: 'Items';		priority: 10;		object: [ {'number' -> self number asString.				'start' -> self start asString.				'end' -> self end asString.				'lines' -> (' ' join: self lines)} asDictionary ];		view: #gtItemsFor:! !!Subtitle methodsFor: 'accessing'!number: anInteger	number := anInteger! !!Subtitle methodsFor: 'accessing'!end: aDuration	end := aDuration.	self newEnd: end.! !!Subtitle methodsFor: 'accessing'!lines	^ lines! !!Subtitle methodsFor: 'accessing'!newEnd	^ newEnd! !!Subtitle methodsFor: 'accessing'!newEnd: aDuration	newEnd := aDuration! !!Subtitle methodsFor: 'accessing'!newStart: aDuration	newStart := aDuration! !!Subtitle methodsFor: 'accessing'!joinedLines	^ ' ' join: self lines! !!Subtitle methodsFor: 'accessing'!start: aDuration	start := aDuration.	self newStart: start.! !!Subtitle methodsFor: 'accessing'!number	^ number! !!Subtitle methodsFor: 'accessing'!start	^ start! !Object subclass: #Subtitles	instanceVariableNames: 'file entries parser'	classVariableNames: ''	package: 'Subtitles'!!Subtitles commentStamp: '' prior: 0!Load in a subtitle file as follows:```subs := Subtitles for: 'subs.srt' asFileReference```Adjust the subs like this:```subs scale: 1 to: 2 minutes + 30 seconds and: 415 to: 1 hour + 33 minutes```Then write out the new subs:```subs writeNewContents```!!Subtitles methodsFor: 'ui'!gtEntriesFor: aView	<gtView>	^ aView columnedList		title: 'Entries';		priority: 10;		items: [ self entries ];		actionUpdateButtonTooltip: 'Update item list';		column: 'Index' text: [ :entry :index | index ] width: 50;		column: 'Start' text: [ :entry | entry start ] width: 100;		column: 'End' text: [ :entry | entry end ] width: 100;		column: 'Lines' text: [ :entry | entry joinedLines ]! !!Subtitles methodsFor: 'ui'!gtNewEntriesFor: aView	<gtView>	^ aView columnedList		title: 'New Entries';		priority: 20;		items: [ self entries ];		actionUpdateButtonTooltip: 'Update item list';		column: 'Index' text: [ :entry :index | index ] width: 50;			column: 'New Start' text: [ :entry | entry newStart ] width: 100;		column: 'New End' text: [ :entry | entry newEnd ] width: 100;		column: 'Lines' text: [ :entry | entry joinedLines ]! !!Subtitles methodsFor: 'instance creation'!parseFile	self entries: (self asPParser parse: self file contents)! !!Subtitles methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: self file basename! !!Subtitles methodsFor: 'conversion'!newContents	| stream |	stream := WriteStream on: String new.	self entries		doWithIndex: [ :each :index | 			stream				nextPutAll: index asString;				nextPutAll: String crlf;				nextPutAll: (self durationAsTime: (each newStart));				nextPutAll: ' --> ';				nextPutAll: (self durationAsTime: (each newEnd));				nextPutAll: String crlf.			(each lines)				do: [ :line | 					stream						nextPutAll: line;						nextPutAll: String crlf ].			stream				nextPutAll: String crlf ].	^ stream contents! !!Subtitles methodsFor: 'conversion'!scaleAll: firstIndex to: newFirst and: lastIndex to: newLast	"scale all the subs using just two reference points	self scaleAll: 1 to: 2 minutes + 30 seconds and: 415 to: 1 hour + 33 minutes"	| oldFirst oldLast scale |	oldFirst := (self entries at: firstIndex) start.	oldLast := (self entries at: lastIndex) start.	scale := (newLast - newFirst) asMilliSeconds			/ (oldLast - oldFirst) asMilliSeconds.	self entries		do: [ :each | 			| newStart newEnd |			newStart := (((each start) - oldFirst) * scale + newFirst)					asMilliSeconds milliseconds asDuration.			newEnd := (((each end) - oldFirst) * scale + newFirst) asMilliSeconds					milliseconds asDuration.			each newStart: newStart.			each newEnd: newEnd ]! !!Subtitles methodsFor: 'conversion'!asDuration: aTime	"Add a DAYS field and change the comma to a period."	^ ('00:' , aTime replaceAll: $, with: $.) asDuration! !!Subtitles methodsFor: 'conversion'!durationAsTime: aDuration	"Adapted from Duration>>#printOn:"	| h m s n stream |	stream := WriteStream on: String new.	h := aDuration hours abs.	m := aDuration minutes abs.	s := aDuration seconds abs truncated.	n := aDuration nanoSeconds abs.	aDuration negative ifTrue: [ stream nextPut: $- ].	h < 10 ifTrue: [ stream nextPut: $0 ].	h printOn: stream.	stream nextPut: $:.	m < 10 ifTrue: [ stream nextPut: $0 ].	m printOn: stream.	stream nextPut: $:.	s < 10 ifTrue: [ stream nextPut: $0 ].	s printOn: stream.	n = 0		ifFalse: [ | ps |			stream nextPut: $,.			ps := n asString padLeftTo: 9 with: $0.			ps				from: 1				to: 3				do: [ :c | stream nextPut: c ] ].	^ stream contents! !!Subtitles methodsFor: 'conversion'!scale: aScalingArray	"Scale subtitles using multiple synchronization points.	self scale: { 1 -> aDuration . ... }"	1		to: aScalingArray size - 1		do: [ :index | 			| start end |			start := aScalingArray at: index.			end := aScalingArray at: index + 1.			self				scale: start key				to: start value				and: end key				to: end value ]! !!Subtitles methodsFor: 'conversion'!scale: firstIndex to: newFirst and: lastIndex to: newLast	"Scale just the subs from firstIndex to lastIndex	self scale: 1 to: 2 minutes + 30 seconds and: 415 to: 1 hour + 33 minutes"	| oldFirst oldLast scale |	oldFirst := (self entries at: firstIndex) start.	oldLast := (self entries at: lastIndex) start.	scale := (newLast - newFirst) asMilliSeconds			/ (oldLast - oldFirst) asMilliSeconds.	firstIndex to: lastIndex		do: [ :index | 			| newStart newEnd each |			each := self entries at: index.			newStart := (((each start) - oldFirst) * scale + newFirst)					asMilliSeconds milliseconds asDuration.			newEnd := (((each end) - oldFirst) * scale + newFirst) asMilliSeconds					milliseconds asDuration.			each newStart: newStart.			each newEnd: newEnd ]! !!Subtitles methodsFor: 'conversion'!writeNewContents	self file parent / (self file basename replaceSuffix: '.srt' with: '-NEW.srt')		writeStreamDo: [ :s | s nextPutAll: self newContents ]! !!Subtitles methodsFor: 'initialization'!file: aFileReference	file := aFileReference! !!Subtitles methodsFor: 'initialization'!initializeEntries	entries := ((String crlf repeat: 2) split: self file asFileReference contents)			collectWithIndex: [ :each :index | 				| lines times |				lines := String crlf split: each.				times := '--> ' split: lines second.				Subtitle new					number: index;					start: (self asDuration: times first);					end: (self asDuration: times second);					lines: (lines allButFirst: 2) ]! !!Subtitles methodsFor: 'as yet unclassified' stamp: 'GlamorousAuthor 1/24/2023 16:31'!data: anArray	data := anArray! !!Subtitles methodsFor: 'accessing'!file	^ file! !!Subtitles methodsFor: 'accessing'!entries: anObject	entries := anObject! !!Subtitles methodsFor: 'accessing'!entries	entries ifNil: [ self initializeEntries ].	^ entries! !!Subtitles methodsFor: 'accessing' stamp: 'GlamorousAuthor 1/24/2023 16:31'!gtSubsFor: aView	<gtView>	data ifNil: [ ^ aView empty ].	^ aView columnedList		title: 'Subtitles';		priority: 10;		items: [ data ];		column: 'Number' text: [ :each | each at: 'Number' ] width: 20;		column: 'Start' text: [ :each | each at: 'Start' ] width: 80;		column: 'End' text: [ :each | each at: 'End' ] width: 80;		column: 'Lines' text: [ :each | ' ' join: (each at: 'Lines') ]! !!Subtitles methodsFor: 'petitparser'!asPParser	| crlf separator number digits time timestamp line linecrlf lines sub subcrlf subFile |	parser		ifNil: [ crlf := #newline asPParser.			separator := crlf plus.			number := (#digit asPParser plus flatten , crlf)					==> [ :node | node first asNumber ].			digits := #digit asPParser plus.			time := (digits , $: asPParser , digits , $: asPParser , digits					, $, asPParser , digits) flatten					==> [ :node | ('00:' , node replaceAll: $, with: $.) asDuration ].			timestamp := time , ' --> ' asPParser , time , crlf.			line := crlf negate plus flatten.			linecrlf := (line , crlf) ==> #first.			lines := (linecrlf / line) plus.			sub := (number , timestamp , lines)					==> [ :nodes | 						Subtitle new							number: nodes first;							start: nodes second first;							end: nodes second third;							lines: nodes third ].			subcrlf := (sub , separator) ==> #first.			subFile := (subcrlf / sub) star.			parser := subFile end ].	^ parser! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Subtitles class	instanceVariableNames: ''!!Subtitles class methodsFor: 'instance creation'!for: aFileReference	^ self new file: aFileReference! !!Subtitles class methodsFor: 'instance creation'!parseFrom: aFileReference	^ self new		file: aFileReference;		parseFile! !